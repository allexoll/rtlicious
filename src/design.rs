//! A file consists of an optional autoindex statement followed by zero or more modules.
//!
//! `<file> ::= <autoidx-stmt>? <module>*`
//!

use crate::{characters, string, value, Design, Span};
use nom::{
    bytes::complete::tag,
    combinator::opt,
    multi::{many0, many1},
    IResult,
};
use nom_tracable::tracable_parser;

impl Design {
    /// Parse a string into a `Design` struct
    pub fn new_from_str(input: &str) -> Result<Design, Span> {
        let input = Span::new_extra(input, Default::default());
        let res = design(input);
        match res {
            Ok((rem, design)) => {
                if rem.fragment().is_empty() {
                    Ok(design)
                } else {
                    Err(rem)
                }
            }
            Err(e) => {
                dbg!(&e);
                Err(input)
            }
        }
    }
}

#[tracable_parser]
/// Parse a Span into a `Design` struct.
/// needed if you want to trace the parsing
fn design(input: Span) -> IResult<Span, Design> {
    // potential comment
    let (input, _) = many0(string::comment)(input)?;
    let (input, autoidx) = opt(autoidx_stmt)(input)?;
    let (input, modules) = many1(crate::module::module)(input)?;
    Ok((
        input,
        Design {
            autoidx,
            modules: modules.into_iter().collect(),
        },
    ))
}

/// Autoindex statements
///
/// The autoindex statement sets the global autoindex value used by Yosys when it needs to generate a unique name, e.g. flattenN. The N part is filled with the value of the global autoindex value, which is subsequently incremented. This global has to be dumped into RTLIL, otherwise e.g. dumping and running a pass would have different properties than just running a pass on a warm design.
///
/// `<autoidx-stmt> ::= autoidx <integer> <eol>`
#[tracable_parser]
pub fn autoidx_stmt(input: Span) -> IResult<Span, i32> {
    let (input, _) = tag("autoidx ")(input)?;
    let (input, integer) = value::integer(input)?;
    let (input, _) = characters::eol(input)?;
    Ok((input, integer))
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;
    #[test]
    fn test_file() {
        let input = indoc! {r#"
        # Generated by Yosys 0.40 (git sha1 a1bb0255d65, clang++ 15.0.0 -fPIC -Os)
        autoidx 3
        attribute \top 1
        attribute \src "vectors/comb_not1.v:2.1-9.10"
        module \comb_not1
          attribute \src "vectors/comb_not1.v:6.5-8.8"
          wire $0\b[0:0]
          attribute \src "vectors/comb_not1.v:7.13-7.15"
          wire $logic_not$vectors/comb_not1.v:7$2_Y
          attribute \src "vectors/comb_not1.v:3.11-3.12"
          wire input 1 \a
          attribute \src "vectors/comb_not1.v:4.12-4.13"
          wire output 2 \b
          attribute \src "vectors/comb_not1.v:7.13-7.15"
          cell $logic_not $logic_not$vectors/comb_not1.v:7$2
            parameter \A_SIGNED 0
            parameter \A_WIDTH 1
            parameter \Y_WIDTH 1
            connect \A \a
            connect \Y $logic_not$vectors/comb_not1.v:7$2_Y
          end
          attribute \src "vectors/comb_not1.v:6.5-8.8"
          process $proc$vectors/comb_not1.v:6$1
            assign { } { }
            assign $0\b[0:0] $logic_not$vectors/comb_not1.v:7$2_Y
            sync always
              update \b $0\b[0:0]
          end
        end
        "#};
        let res = Design::new_from_str(input).unwrap();
        assert!(!res.modules.is_empty());
    }
    #[test]
    fn test_autoidx_stmt() {
        let vectors = vec![
            ("autoidx 0\n", 0),
            ("autoidx 1\n", 1),
            ("autoidx 2\n", 2),
            ("autoidx 3\n", 3),
            ("autoidx 4\n", 4),
            ("autoidx 5\n", 5),
            ("autoidx 6\n", 6),
            ("autoidx 7\n", 7),
            ("autoidx 8\n", 8),
            ("autoidx 9\n", 9),
            ("autoidx 10\n", 10),
        ];
        for (input, expected) in vectors {
            let span = Span::new_extra(input, Default::default());
            let ret = autoidx_stmt(span).unwrap();
            assert_eq!(ret.1, expected);
        }
    }
}
